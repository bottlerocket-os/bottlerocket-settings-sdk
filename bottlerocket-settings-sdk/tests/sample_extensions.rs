//! Rust integration tests don't load modules by default.
//! This file is picked up by the integration tester and directs it to integration test submodules.
use anyhow::{Context, Result};
use bottlerocket_settings_sdk::model::AsTypeErasedModel;
use bottlerocket_settings_sdk::{GenerateResult, Migrator, SettingsExtension};
pub use helpers::*;
use log::LevelFilter;
use serde::de::DeserializeOwned;

#[ctor::ctor]
fn setup_logging() {
    env_logger::builder()
        .filter_level(LevelFilter::Trace)
        .is_test(true)
        .init();
}

mod colliding_versions;
mod migration_validation;
mod motd;

/// We also define some helpers for invoking the CLI interface generated by the SDK.
mod helpers {
    use super::*;
    use bottlerocket_settings_sdk::cli::proto1::{
        FloodMigrateArguments, GenerateArguments, MigrateArguments, SetArguments,
        TemplateHelperArguments, ValidateArguments,
    };

    fn cli<Mi, Mo>(
        extension: SettingsExtension<Mi, Mo>,
        subcommand: &str,
        args: impl serde::Serialize,
    ) -> Result<serde_json::Value>
    where
        Mi: Migrator<ModelKind = Mo>,
        Mo: AsTypeErasedModel,
    {
        let temp_dir = tempfile::TempDir::new().context("Failed to create temp dir")?;
        let input_file = std::path::Path::join(temp_dir.path(), "input.json");
        let _ = std::fs::write(
            &input_file,
            serde_json::to_string(&args).context("Failed to serialize args")?,
        );

        extension
            .try_run_with_args(&[
                "extension",
                "proto1",
                "--input-file",
                input_file.to_str().unwrap(),
                subcommand,
            ])
            .context("Failed to run settings extension CLI")
            .and_then(|s| {
                if s.is_empty() {
                    return Ok(serde_json::Value::default());
                }
                serde_json::from_str(s.as_str()).context("Failed to parse CLI result")
            })
    }

    /// Wrapper around "extension.set" which uses the CLI.
    pub fn set_cli<Mi, Mo>(
        extension: SettingsExtension<Mi, Mo>,
        version: &str,
        value: serde_json::Value,
    ) -> Result<()>
    where
        Mi: Migrator<ModelKind = Mo>,
        Mo: AsTypeErasedModel,
    {
        cli(
            extension,
            "set",
            SetArguments {
                setting_version: String::from(version),
                value,
                current_value: None,
            },
        )
        .context("failed to run set CLI")
        .map(|v| {
            assert!(v.is_null());
            ()
        })
    }

    /// Wrapper around "extension.generate" which uses the CLI.
    pub fn generate_cli<Mi, Mo, P, C>(
        extension: SettingsExtension<Mi, Mo>,
        version: &str,
        existing_partial: Option<serde_json::Value>,
        required_settings: Option<serde_json::Value>,
    ) -> Result<GenerateResult<P, C>>
    where
        Mi: Migrator<ModelKind = Mo>,
        Mo: AsTypeErasedModel,
        P: DeserializeOwned,
        C: DeserializeOwned,
    {
        cli(
            extension,
            "generate",
            GenerateArguments {
                setting_version: String::from(version),
                existing_partial,
                required_settings,
            },
        )
        .context("failed to run generate CLI")
        .and_then(|v| {
            serde_json::from_value(v).context("failed to convert json value to concrete type")
        })
    }

    /// Wrapper around "extension.validate" which uses the CLI.
    pub fn validate_cli<Mi, Mo>(
        extension: SettingsExtension<Mi, Mo>,
        version: &str,
        value: serde_json::Value,
        required_settings: Option<serde_json::Value>,
    ) -> Result<()>
    where
        Mi: Migrator<ModelKind = Mo>,
        Mo: AsTypeErasedModel,
    {
        cli(
            extension,
            "validate",
            ValidateArguments {
                setting_version: String::from(version),
                value,
                required_settings,
            },
        )
        .context("failed to run set CLI")
        .map(|v| {
            assert!(v.is_null());
            ()
        })
    }

    /// Wrapper around target migrations which uses the CLI.
    pub fn target_migrate_cli<Mi, Mo>(
        extension: SettingsExtension<Mi, Mo>,
        value: serde_json::Value,
        from_version: &str,
        target_version: &str,
    ) -> Result<serde_json::Value>
    where
        Mi: Migrator<ModelKind = Mo>,
        Mo: AsTypeErasedModel,
    {
        cli(
            extension,
            "migrate",
            MigrateArguments {
                value,
                from_version: from_version.to_string(),
                target_version: target_version.to_string(),
            },
        )
    }

    /// Wrapper around flood migrations which uses the CLI.
    pub fn flood_migrate_cli<Mi, Mo>(
        extension: SettingsExtension<Mi, Mo>,
        value: serde_json::Value,
        from_version: &str,
    ) -> Result<serde_json::Value>
    where
        Mi: Migrator<ModelKind = Mo>,
        Mo: AsTypeErasedModel,
    {
        cli(
            extension,
            "flood-migrate",
            FloodMigrateArguments {
                value,
                from_version: from_version.to_string(),
            },
        )
    }

    /// Wrapper around "extension.template_helper" which uses the CLI.
    pub fn template_helper_cli<Mi, Mo>(
        extension: SettingsExtension<Mi, Mo>,
        version: &str,
        helper_name: &str,
        args: Vec<serde_json::Value>,
    ) -> Result<serde_json::Value>
    where
        Mi: Migrator<ModelKind = Mo>,
        Mo: AsTypeErasedModel,
    {
        cli(
            extension,
            "helper",
            TemplateHelperArguments {
                setting_version: String::from(version),
                helper_name: helper_name.to_string(),
                arg: args,
            },
        )
    }
}
